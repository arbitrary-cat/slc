// Copyright (c) 2016, Sam Payson
//
// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
// associated documentation files (the "Software"), to deal in the Software without restriction,
// including without limitation the rights to use, copy, modify, merge, publish, distribute,
// sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all copies or
// substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT
// NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

use std::io;

use compiler::CtxRef;
use error;
use pattern::Pattern;
use syntax::{self, Node, GenNode};
use types::Type;
use util;

const PREFIX: &'static str = "SL_";

pub type TempMap<'ctx> = util::TagMap<'ctx, &'ctx str>;

pub type TypedefMap<'ctx> = util::TagMap<'ctx, &'ctx str>;

/// A buffer which can be used to build a C file.
pub struct CBuffer<'ctx> {
    next_uniq: usize,

    /// A string to use as scratch space for constructing identifiers (which can then be stored using
    /// the StrArena).
    pub scratch: String,

    /// This string is similar to scratch, but it's used for building the RHS of assignments in the
    /// Pattern::assign method. See the implementation for `syntax::TuplePattern` in pattern.rs for
    /// an example of its use.
    pub field: String,

    /// A mapping from expression nodes to temporary variable names (used to store sub-expressions).
    pub tmp_map: TempMap<'ctx>,

    /// A mapping from SL types to their C typedef names.
    pub typedef_map: TypedefMap<'ctx>,

    /// Text for all C typedef code.
    pub typedefs_txt: Vec<u8>,

    /// Text for C function prototypes.
    pub fn_protos_txt: Vec<u8>,

    /// Text for C function implementations (the actual code!).
    pub fn_impls_txt: Vec<u8>,

    pub indent: String,
}

impl<'ctx> CBuffer<'ctx> {
    pub fn new()
    -> CBuffer<'ctx>
    {
        CBuffer {
            next_uniq:     0,
            scratch:       String::new(),
            field:         String::new(),
            tmp_map:       TempMap::new(),
            typedef_map:   TypedefMap::new(),
            typedefs_txt:  Vec::new(),
            fn_protos_txt: Vec::new(),
            fn_impls_txt:  Vec::new(),
            indent:        String::new(),
        }
    }

    pub fn inc_indent(&mut self) {
        self.indent.push('\t');
    }


    pub fn dec_indent(&mut self) {
        self.indent.pop();
    }

    pub fn write<W: io::Write>(&self, w: &mut W)
    -> io::Result<()> {
        try!(fcatln!(w, "// Generated by the SL compiler\n"));
        try!(fcatln!(w, "\n// C Typedefs:\n"));
        try!(w.write_all(&self.typedefs_txt[..]));
        try!(fcatln!(w, "\n// C Function Prototypes:\n"));
        try!(w.write_all(&self.fn_protos_txt[..]));

        try!(fcatln!(w, "\n// C Function Implementations:\n"));
        w.write_all(&self.fn_impls_txt[..])

    }

    pub fn get_uniq(&mut self)
    -> usize
    {
        let uniq = self.next_uniq;
        self.next_uniq = self.next_uniq + 1;

        uniq
    }

    pub fn typedef(&mut self, ctx: CtxRef<'ctx>, ty: &'ctx Type<'ctx>)
    -> error::Result<'ctx, &'ctx str>
    {
        if let Some(typedef_name) = self.typedef_map.get(ty) {
            return Ok(typedef_name);
        } 

        self.scratch.clear();
        let uniq = self.get_uniq();

        match ty {
            &Type::Int  => strcat!(self.scratch, PREFIX, "int_t"),
            &Type::Unit => strcat!(self.scratch, PREFIX, "unit_t"),
            &Type::Bool => strcat!(self.scratch, PREFIX, "bool_t"),
            &Type::Func { .. }  => strcat!(self.scratch, PREFIX, "fn", uniq, "_t"),
            &Type::Tuple { .. } => strcat!(self.scratch, PREFIX, "tuple", uniq, "_t"),
        }

        let name = ctx.strings.alloc(&self.scratch[..]);

        try!(ty.emit_typedef(name, ctx, self));

        self.typedef_map.insert(ty, name);

        Ok(name)
    }


    /// Return a unique temporary name, associated with this expression. `temp_for` always returns
    /// the same string for the same expression.
    pub fn temp_for<E>(&mut self, hint: &str, ctx: CtxRef<'ctx>, expr: &'ctx E)
    -> &'ctx str
    where E: util::Tagged<'ctx>
    {
        if let Some(tmp) = self.tmp_map.get(expr) {
            tmp
        } else {
            self.scratch.clear();
            let uniq = self.get_uniq();
            strcat!(self.scratch, PREFIX, hint, "_", uniq);
            let name = ctx.strings.alloc(&self.scratch[..]);
            self.tmp_map.insert(expr, name);

            name
        }
    }
}

impl<'ctx> Type<'ctx> {
    // Emit a C-syntax typedef to the typedefs_txt section.
    fn emit_typedef(&'ctx self, td: &str, ctx: CtxRef<'ctx>, c: &mut CBuffer<'ctx>)
    -> error::Result<'ctx, ()>
    {
        fcatln!(c.typedefs_txt,"// ", self).ok();
        match self {
            &Type::Func { from, to } => {
                let ret_t = try!(c.typedef(ctx, to));
                fcat!(c.typedefs_txt, "typedef ", ret_t, " (*", td, ")(").ok();
                match from {
                    &Type::Tuple { ref elems } => {
                        let mut args_t = Vec::with_capacity(elems.len());
                        for &elem in elems.iter() {
                            args_t.push(try!(c.typedef(ctx, elem)))
                        }

                        for (idx, &arg_t) in args_t.iter().enumerate() {
                            fcat!(c.typedefs_txt, if idx > 0 { ", " } else { "" }, arg_t).ok();
                        }
                    }
                    ty => {
                        let c_name = try!(c.typedef(ctx, ty));
                        fcat!(c.typedefs_txt, c_name).ok();
                    },
                }
                fcatln!(c.typedefs_txt, ");\n").ok();
            }
            &Type::Tuple { ref elems } => {
                fcatln!(c.typedefs_txt, "typedef struct ", td, " {\n").ok();
                for (idx, &elem) in elems.iter().enumerate() {
                    let elem_t = try!(c.typedef(ctx, elem));
                    fcatln!(c.typedefs_txt, "\t// ", elem_t).ok();
                    fcatln!(c.typedefs_txt, "\t", elem_t, " _", idx, ";\n").ok();
                }
                fcatln!(c.typedefs_txt, "} ", td, ";\n").ok();
            }
            &Type::Int | &Type::Bool => {
                fcatln!(c.typedefs_txt, "typedef int ", td, ";\n").ok();
            }

            &Type::Unit => {
                fcatln!(c.typedefs_txt, "typedef struct ", td, " { char _; } ", td, ";\n").ok();
            }
        }

        Ok(())
    }
}

/// A trait for nodes which can be emitted as C code.
pub trait EmitC<'ctx> {
    /// Emit the code for this node.
    fn emit(&'ctx self, ctx: CtxRef<'ctx>, c: &mut CBuffer<'ctx>)
    -> error::Result<'ctx, ()>
    ;

    /// Emit any C-code which must precede this. The default implementation does nothing.
    fn depends(&'ctx self, ctx: CtxRef<'ctx>, c: &mut CBuffer<'ctx>)
    -> error::Result<'ctx, ()>
    {
        #![allow(unused_variables)]
        Ok(())
    }
}


impl<'ctx> EmitC<'ctx> for syntax::Node<'ctx> {
    fn depends(&'ctx self, ctx: CtxRef<'ctx>, c: &mut CBuffer<'ctx>)
    -> error::Result<'ctx, ()>
    {
        use syntax::Node::*;

        if let Some(..) = c.tmp_map.get(self) { return Ok(()) }

        match self {
            &TranslationUnit(ref translation_unit) => translation_unit.depends(ctx, c),
            &FnDecl(ref fn_decl)                   => fn_decl.depends(ctx, c),
            &BinOp(ref bin_op)                     => bin_op.depends(ctx, c),
            &Ident(ref ident)                      => ident.depends(ctx, c),
            &Tuple(ref tuple)                      => tuple.depends(ctx, c),
            &FnCall(ref fn_call)                   => fn_call.depends(ctx, c),
            &IfExpr(ref if_expr)                   => if_expr.depends(ctx, c),
            &IntLit(ref int_lit)                   => int_lit.depends(ctx, c),
            &LetExpr(ref let_expr)                 => let_expr.depends(ctx, c),
            &Block(ref block)                      => block.depends(ctx, c),
            _ => return Err(error::Error::InternalError {
                loc: Some(self.loc()),
                msg: scat!("Node type `", self, "' cannot be emitted as C."),
            }),
        }
    }

    fn emit(&'ctx self, ctx: CtxRef<'ctx>, c: &mut CBuffer<'ctx>)
    -> error::Result<'ctx, ()>
    {
        use syntax::Node::*;

        // For expressions with a temporary already generated, we simply emit them by emitting their
        // assigned identifier. This will always happen in the `fn_impls_txt` section.
        if let Some(tmp) = c.tmp_map.get(self) {
            fcat!(c.fn_impls_txt, tmp).ok();

            return Ok(());
        }

        match self {
            &TranslationUnit(ref translation_unit) => translation_unit.emit(ctx, c),
            &FnDecl(ref fn_decl)                   => fn_decl.emit(ctx, c),
            &BinOp(ref bin_op)                     => bin_op.emit(ctx, c),
            &Ident(ref ident)                      => ident.emit(ctx, c),
            &Tuple(ref tuple)                      => tuple.emit(ctx, c),
            &FnCall(ref fn_call)                   => fn_call.emit(ctx, c),
            &IfExpr(ref if_expr)                   => if_expr.emit(ctx, c),
            &IntLit(ref int_lit)                   => int_lit.emit(ctx, c),
            &LetExpr(ref let_expr)                 => let_expr.emit(ctx, c),
            &Block(ref block)                      => block.emit(ctx, c),
            _ => return Err(error::Error::InternalError {
                loc: Some(self.loc()),
                msg: scat!("Node type `", self, "' cannot be emitted as C."),
            }),
        }
    }
}

impl<'ctx> EmitC<'ctx> for syntax::TranslationUnit<'ctx> {
    fn emit(&'ctx self, ctx: CtxRef<'ctx>, c: &mut CBuffer<'ctx>)
    -> error::Result<'ctx, ()>
    {
        for &fn_decl in self.fn_decls.iter() {
            try!(fn_decl.depends(ctx, c));
            try!(fn_decl.emit(ctx, c));
        }

        Ok(())
    }
}

// Where should a function signature be emitted?
//
// This type is just for use with FnDecl::print_sig.
#[derive(Clone,Copy)] enum SigLoc {
    Proto,
    Impl,
}

impl SigLoc {
    fn get_buffer<'x>(self, c: &'x mut CBuffer)
    -> &'x mut Vec<u8>
    {
        match self {
            SigLoc::Proto => &mut c.fn_protos_txt,
            SigLoc::Impl  => &mut c.fn_impls_txt,
        }
    }
}

impl<'ctx> syntax::FnDecl<'ctx> {
    fn print_sig(&'ctx self, sig_loc: SigLoc, ctx: CtxRef<'ctx>, c: &mut CBuffer<'ctx>)
    -> error::Result<'ctx, ()>
    {
        let mut comma = None;

        let ret_t: &'ctx str = try!(c.typedef(ctx, self.to));

        fcat!(sig_loc.get_buffer(c), ret_t, " ", self.name.text(), "(").ok();

        // Check for the special case where the function has a single tuple argument.
        match self.args.first().cloned() {
            Some(&Node::VarDecl(syntax::VarDecl {
                ref names,
                ty: &Type::Tuple {
                    ref elems
                },
            })) if self.args.len() == 1 && names.len() == 1 => {
                let c_id = names.first().unwrap().text();
                for (idx, &elem_t) in elems.iter().enumerate() {
                    let c_ty = try!(c.typedef(ctx, elem_t));
                    fcat!(sig_loc.get_buffer(c), comma, c_ty, " ", c_id, "_", idx).ok();
                    comma = Some(", ");
                }
            }

            _ => for &n in self.args.iter() {
                let var_decl: &'ctx syntax::VarDecl<'ctx> = n.as_ref();
                for &name in var_decl.names.iter() {
                    let c_id = name.text();
                    let c_ty = try!(c.typedef(ctx, var_decl.ty));
                    fcat!(sig_loc.get_buffer(c), comma, c_ty, " ", c_id).ok();
                    comma = Some(", ");
                }
            }
        }

        fcat!(sig_loc.get_buffer(c), ")").ok();

        Ok(())
    }
}

impl<'ctx> EmitC<'ctx> for syntax::FnDecl<'ctx> {
    fn emit(&'ctx self, ctx: CtxRef<'ctx>, c: &mut CBuffer<'ctx>)
    -> error::Result<'ctx, ()>
    {
        try!(self.print_sig(SigLoc::Proto, ctx, c));
        fcatln!(c.fn_protos_txt, ";\n").ok();

        try!(self.print_sig(SigLoc::Impl, ctx, c));
        fcatln!(c.fn_impls_txt, " {").ok();
        c.inc_indent();

        // Check for the special case where the function has a single tuple argument.
        match self.args.first().cloned() {
            Some(&Node::VarDecl(syntax::VarDecl {
                ref names, ty
            })) if self.args.len() == 1 && names.len() == 1 => {
                let tuple_t = try!(c.typedef(ctx, ty));
                let c_id = names.first().unwrap().text();

                // Awkward second pattern match because we're not allowed to bind a name to `ty` and
                // an internal field at the same time.
                if let &Type::Tuple { ref elems } = ty {
                    fcatln!(c.fn_impls_txt, c.indent, tuple_t, " ", c_id, ";").ok();

                    for (idx, _) in elems.iter().enumerate() {
                        fcatln!(
                            c.fn_impls_txt, c.indent, c_id, "._", idx, " = ", c_id, "_", idx, ";"
                        ).ok();
                    }

                }
            }
            _ => (),
        }

        // Add a newline at the top of the function (possibly after some tuple shenanigans) for
        // readability.
        fcatln!(c.fn_impls_txt, "").ok();

        try!(self.body.depends(ctx, c));

        fcat!(c.fn_impls_txt, c.indent, "return ").ok();
        try!(self.body.emit(ctx, c));

        c.dec_indent();
        fcatln!(c.fn_impls_txt, ";\n", c.indent, "}\n").ok();

        Ok(())
    }
}

impl<'ctx> EmitC<'ctx> for syntax::BinOp<'ctx> {
    fn depends(&'ctx self, ctx: CtxRef<'ctx>, c: &mut CBuffer<'ctx>)
    -> error::Result<'ctx, ()>
    {
        try!(self.lhs.depends(ctx, c));
        try!(self.rhs.depends(ctx, c));

        Ok(())
    }

    fn emit(&'ctx self, ctx: CtxRef<'ctx>, c: &mut CBuffer<'ctx>)
    -> error::Result<'ctx, ()>
    {
        fcat!(c.fn_impls_txt, "(").ok();
        try!(self.lhs.emit(ctx, c));
        fcat!(c.fn_impls_txt, " ", self.op.text(), " ").ok();
        try!(self.rhs.emit(ctx, c));
        fcat!(c.fn_impls_txt, ")").ok();

        Ok(())
    }
}

impl<'ctx> EmitC<'ctx> for syntax::Ident<'ctx> {
    /// This implementation assumes the ident is being emitted as an identifier in an expression. It
    /// will go to the function impls buffer.
    fn emit(&'ctx self, _ctx: CtxRef<'ctx>, c: &mut CBuffer<'ctx>)
    -> error::Result<'ctx, ()>
    {
        fcat!(c.fn_impls_txt, self.text()).ok();
        Ok(())
    }
}


impl<'ctx> EmitC<'ctx> for syntax::Tuple<'ctx> {
    fn depends(&'ctx self, ctx: CtxRef<'ctx>, c: &mut CBuffer<'ctx>)
    -> error::Result<'ctx, ()>
    {
        let c_t = {
            let ty = ctx.ty_map.get(self).expect("Tuple not annotated with type.");
            try!(c.typedef(ctx, ty))
        };

        for &elem in self.elems.iter() {
            try!(elem.depends(ctx, c));
        }

        let tmp_id = c.temp_for("tpl", ctx, self);

        fcatln!(c.fn_impls_txt, c.indent, c_t, " ", tmp_id, ";").ok();

        for (idx, &elem) in self.elems.iter().enumerate() {
            fcat!(c.fn_impls_txt, c.indent, tmp_id, "._", idx, " = ").ok();
            try!(elem.emit(ctx, c));
            fcatln!(c.fn_impls_txt, ";").ok();
        }

        fcat!(c.fn_impls_txt, "\n").ok();

        Ok(())
    }

    fn emit(&'ctx self, _ctx: CtxRef<'ctx>, c: &mut CBuffer<'ctx>)
    -> error::Result<'ctx, ()>
    {
        let tmp_id = c.tmp_map.get(self).expect("Tuple not annotated with temporary.");

        fcat!(c.fn_impls_txt, tmp_id).ok();

        Ok(())
    }
}

impl<'ctx> EmitC<'ctx> for syntax::FnCall<'ctx> {
    fn depends(&'ctx self, ctx: CtxRef<'ctx>, c: &mut CBuffer<'ctx>)
    -> error::Result<'ctx, ()>
    {
        use syntax::Node;
        use syntax::Tuple;

        let ret_t = {
            let ty = ctx.ty_map.get(self).expect("Fn Call not annotated with type.");
            try!(c.typedef(ctx, ty))
        };

        let tmp_id = c.temp_for("ret", ctx, self);

        try!(self.fun.depends(ctx, c));

        match self.arg {
            &Node::Tuple(Tuple { ref elems, .. }) => {
                for &elem in elems.iter() {
                    try!(elem.depends(ctx, c));
                }
            }
            _ => try!(self.arg.depends(ctx, c)),
        }

        fcat!(c.fn_impls_txt, c.indent, ret_t, " ", tmp_id, " = ").ok();

        try!(self.fun.emit(ctx, c));
        fcat!(c.fn_impls_txt, "(").ok();
        match self.arg {
            &Node::Tuple(Tuple { ref elems, .. }) => {
                for (idx, &elem) in elems.iter().enumerate() {
                    fcat!(c.fn_impls_txt, if idx > 0 { ", " } else { "" }).ok();
                    try!(elem.emit(ctx, c));
                }
            }
            _ => match ctx.ty_map.get(self.arg).expect("Fn Argument not annotated with type.") {

                &Type::Tuple { ref elems } => {
                    for (idx, _) in elems.iter().enumerate() {
                        fcat!(c.fn_impls_txt, if idx > 0 { ", " } else { "" }).ok();
                        try!(self.arg.emit(ctx, c));
                        fcat!(c.fn_impls_txt, "._", idx).ok();
                    }
                }

                _ => { try!(self.arg.emit(ctx, c)); }
            },
        }

        fcatln!(c.fn_impls_txt, ");\n").ok();

        Ok(())
    }

    fn emit(&'ctx self, ctx: CtxRef<'ctx>, c: &mut CBuffer<'ctx>)
    -> error::Result<'ctx, ()>
    {
        let tmp = c.temp_for("<>", ctx, self);
        fcat!(c.fn_impls_txt, tmp).ok();

        Ok(())
    }
}

impl<'ctx> EmitC<'ctx> for syntax::IfExpr<'ctx> {
    fn depends(&'ctx self, ctx: CtxRef<'ctx>, c: &mut CBuffer<'ctx>)
    -> error::Result<'ctx, ()>
    {
        let if_t = {
            let ty = ctx.ty_map.get(self).expect("If Expr not annotated with type.");
            try!(c.typedef(ctx, ty))
        };

        let tmp_id = c.temp_for("ifres", ctx, self);
        
        try!(self.cond.depends(ctx, c));

        fcat!(c.fn_impls_txt, c.indent, if_t, " ", tmp_id, "; if (").ok();
        try!(self.cond.emit(ctx, c));
        fcatln!(c.fn_impls_txt, ") {").ok();
        c.inc_indent();

        try!(self.yes.depends(ctx, c));
        fcat!(c.fn_impls_txt, c.indent, tmp_id, " = ").ok();
        try!(self.yes.emit(ctx, c));
        fcatln!(c.fn_impls_txt, ";").ok();

        c.dec_indent();

        fcatln!(c.fn_impls_txt, c.indent, "} else {").ok();
        c.inc_indent();

        let no = self.no.expect("If Expr without matching else got to codegen.");

        try!(no.depends(ctx, c));
        fcat!(c.fn_impls_txt, c.indent, tmp_id, " = ").ok();
        try!(no.emit(ctx, c));
        fcatln!(c.fn_impls_txt, ";").ok();
        
        c.dec_indent();

        fcatln!(c.fn_impls_txt, c.indent, "}\n").ok();

        Ok(())
    }

    fn emit(&'ctx self, ctx: CtxRef<'ctx>, c: &mut CBuffer<'ctx>)
    -> error::Result<'ctx, ()>
    {
        let tmp = c.temp_for("<>", ctx, self);
        fcat!(c.fn_impls_txt, tmp).ok();

        Ok(())
    }
}

impl<'ctx> EmitC<'ctx> for syntax::IntLit<'ctx> {
    fn emit(&'ctx self, _ctx: CtxRef<'ctx>, c: &mut CBuffer<'ctx>)
    -> error::Result<'ctx, ()>
    {
        use source::TokenData;

        match self.tok.data {
            TokenData::Int(n) => { fcat!(c.fn_impls_txt, n).ok(); },
            _ => return Err(error::Error::InternalError {
                loc: Some(self.tok.loc),
                msg: scat!("token is not an integer literal"),
            }),
        }

        Ok(())
    }
}

impl<'ctx> EmitC<'ctx> for syntax::LetExpr<'ctx> {
    fn depends(&'ctx self, ctx: CtxRef<'ctx>, c: &mut CBuffer<'ctx>)
    -> error::Result<'ctx, ()>
    {

        try!(self.val.depends(ctx, c));

        let tmp = if let Some(body) = self.body {
            // Declare the temporary that will hold the value of the let expression.
            let tmp = c.temp_for("let", ctx, self);
            let body_t = {
                let ty = ctx.ty_map.get(body).expect("Let body not annotated with type.");
                try!(c.typedef(ctx, ty))
            };

            // Note that we're entering a new C scope here.
            fcatln!(c.fn_impls_txt, c.indent, body_t, " ", tmp, "; {").ok();

            c.inc_indent();

            tmp
        } else {
            // Invalid C identifier
            "<?>"
        };

        // Declare the temporary that will hold the value being destructured by the pattern.
        let field = c.temp_for("pat", ctx, self.pat);

        let val_t = {
            let ty = ctx.ty_map.get(self.val).expect("Let RHS not annotated with type.");
            try!(c.typedef(ctx, ty))
        };

        fcat!(c.fn_impls_txt, c.indent, val_t, " ", field, " = ").ok();
        try!(self.val.emit(ctx, c));
        fcatln!(c.fn_impls_txt, ";").ok();

        c.field.clear();
        c.field.push_str(field);

        try!(self.pat.assign(ctx, c));

        if let Some(body) = self.body {
            try!(body.depends(ctx, c));

            fcat!(c.fn_impls_txt, c.indent, tmp, " = ").ok();
            try!(body.emit(ctx, c));
            fcatln!(c.fn_impls_txt, ";").ok();

            c.dec_indent();
            fcatln!(c.fn_impls_txt, c.indent, "}").ok();
        }

        fcat!(c.fn_impls_txt, "\n").ok();

        Ok(())
    }

    fn emit(&'ctx self, ctx: CtxRef<'ctx>, c: &mut CBuffer<'ctx>)
    -> error::Result<'ctx, ()>
    {
        let tmp = c.temp_for("<>", ctx, self);
        fcat!(c.fn_impls_txt, tmp).ok();

        Ok(())
    }
}

impl<'ctx> EmitC<'ctx> for syntax::Block<'ctx> {
    fn depends(&'ctx self, ctx: CtxRef<'ctx>, c: &mut CBuffer<'ctx>)
    -> error::Result<'ctx, ()>
    {
        // Declare the temporary that will hold the value of the block.

        let tmp = c.temp_for("block", ctx, self);

        let blk_t = {
            let ty = ctx.ty_map.get(self).expect("Block not annotated with type.");
            try!(c.typedef(ctx, ty))
        };

        fcatln!(c.fn_impls_txt, c.indent, blk_t, " ", tmp, "; {\n").ok();

        c.inc_indent();
        for &expr in self.exprs.iter() {
            try!(expr.depends(ctx, c));
        }

        if self.unit {
            let unit_t = try!(c.typedef(ctx, ctx.types.unit()));
            // Pretty sure this puts the generated code firmly in the GNU C camp.
            fcatln!(c.fn_impls_txt, c.indent, tmp, " = (", unit_t, ") {0};").ok();
        } else {
            fcat!(c.fn_impls_txt, c.indent, tmp, " = ").ok();
            try!(self.exprs.last().cloned().unwrap().emit(ctx, c));
            fcatln!(c.fn_impls_txt, ";").ok();
        }

        c.dec_indent();
        fcatln!(c.fn_impls_txt, c.indent, "}\n").ok();

        Ok(())
    }

    fn emit(&'ctx self, ctx: CtxRef<'ctx>, c: &mut CBuffer<'ctx>)
    -> error::Result<'ctx, ()>
    {
        let tmp = c.temp_for("<>", ctx, self);
        fcat!(c.fn_impls_txt, tmp).ok();

        Ok(())
    }
}
